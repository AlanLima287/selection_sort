#pragma once

#include <fstream>
#include <iostream>

const unsigned char basic_font_data[] = {
   0x00, 0x00, 0x00, 0x00, 0x44, 0x44, 0x04, 0x00, 0xaa, 0x00, 0x00, 0x00, 0x05, 0xf5, 0xf5,
   0x00, 0x27, 0xa6, 0x5f, 0x40, 0x9a, 0x24, 0x59, 0x00, 0x0e, 0xac, 0xda, 0xf0, 0x44, 0x00,
   0x00, 0x00, 0x34, 0x88, 0x84, 0x30, 0xc2, 0x11, 0x12, 0xc0, 0x0a, 0x4a, 0x00, 0x00, 0x00,
   0x27, 0x20, 0x00, 0x00, 0x00, 0x22, 0x40, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
   0x12, 0x24, 0x48, 0x00, 0xf9, 0xbd, 0x9f, 0x00, 0x4c, 0x44, 0x4e, 0x00, 0x69, 0x16, 0x8f,
   0x00, 0x69, 0x21, 0x96, 0x00, 0x99, 0xf1, 0x11, 0x00, 0xf8, 0xf1, 0x1f, 0x00, 0xf8, 0xf9,
   0x9f, 0x00, 0xf1, 0x22, 0x44, 0x00, 0x69, 0x69, 0x96, 0x00, 0xf9, 0xf1, 0x1f, 0x00, 0x04,
   0x00, 0x40, 0x00, 0x04, 0x00, 0x48, 0x00, 0x00, 0x16, 0x86, 0x10, 0x00, 0x0f, 0x0f, 0x00,
   0x00, 0x86, 0x16, 0x80, 0x69, 0x12, 0x02, 0x00, 0x35, 0x9b, 0xb8, 0x70, 0x69, 0x9f, 0x99,
   0x00, 0xe9, 0xe9, 0x9f, 0x00, 0xf8, 0x88, 0x8f, 0x00, 0xe9, 0x99, 0x9f, 0x00, 0xf8, 0xe8,
   0x8f, 0x00, 0xf8, 0xe8, 0x88, 0x00, 0xf8, 0x8b, 0x9f, 0x00, 0x99, 0xf9, 0x99, 0x00, 0xe4,
   0x44, 0x4e, 0x00, 0xf2, 0x22, 0xae, 0x00, 0xaa, 0xca, 0xaa, 0x00, 0x88, 0x88, 0x8e, 0x00,
   0xbd, 0x99, 0x99, 0x00, 0x9d, 0xb9, 0x99, 0x00, 0xf9, 0x99, 0x9f, 0x00, 0xe9, 0x9e, 0x88,
   0x00, 0xf9, 0x99, 0xbf, 0x00, 0xe9, 0x9e, 0x99, 0x00, 0x78, 0x61, 0x1e, 0x00, 0xe4, 0x44,
   0x44, 0x00, 0x99, 0x99, 0x9f, 0x00, 0x99, 0x99, 0x96, 0x00, 0x99, 0x99, 0xdb, 0x00, 0xaa,
   0x4a, 0xaa, 0x00, 0xaa, 0xe4, 0x44, 0x00, 0xf1, 0x24, 0x8f, 0x00, 0xe8, 0x88, 0x88, 0xe0,
   0x84, 0x42, 0x21, 0x00, 0xe2, 0x22, 0x22, 0xe0, 0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f,
   0x00, 0x42, 0x00, 0x00, 0x00, 0x06, 0x17, 0x97, 0x00, 0x08, 0x8e, 0x9e, 0x00, 0x00, 0x78,
   0x87, 0x00, 0x01, 0x17, 0x97, 0x00, 0x06, 0x9e, 0x87, 0x00, 0x07, 0x8e, 0x88, 0x00, 0x00,
   0x79, 0xf1, 0xe0, 0x08, 0x8e, 0xaa, 0x00, 0x04, 0x0c, 0x4e, 0x00, 0x02, 0x06, 0x2a, 0xc0,
   0x08, 0xac, 0xaa, 0x00, 0x0c, 0x44, 0x4e, 0x00, 0x00, 0xfd, 0x99, 0x00, 0x00, 0x9d, 0xb9,
   0x00, 0x00, 0x69, 0x96, 0x00, 0x00, 0xe9, 0x9e, 0x80, 0x00, 0x79, 0x97, 0x10, 0x00, 0xb4,
   0x44, 0x00, 0x00, 0x78, 0x61, 0xe0, 0x04, 0xf4, 0x45, 0x60, 0x00, 0xaa, 0xae, 0x00, 0x00,
   0xaa, 0xa4, 0x00, 0x00, 0x99, 0xdf, 0x00, 0x00, 0xa4, 0xaa, 0x00, 0x00, 0x99, 0x53, 0xe0,
   0x00, 0xf1, 0x68, 0xf0, 0x34, 0x48, 0x44, 0x30, 0x44, 0x44, 0x44, 0x00, 0xc2, 0x21, 0x22,
   0xc0, 0x00, 0x69, 0x00, 0x00
};

class Font {

   typedef unsigned char uchar;
   typedef unsigned long ulong;

   ulong sheet_length_in_bytes;
   uchar* character_sheet;
   bool is_basic;

public:

   uchar height, width;
   ulong sheet_length;

   Font() :sheet_length_in_bytes(0), character_sheet(nullptr),
      height(0), width(0), sheet_length(0) {}

   ~Font() { if (character_sheet && !is_basic) delete[] character_sheet; }

   Font(const Font&) = delete;
   Font operator=(const Font&) = delete;

private:

   void loadBasic() {
      sheet_length_in_bytes = 4;
      character_sheet = (uchar*)basic_font_data;
      sheet_length = 28;
      is_basic = true;
      height = 7;
      width = 4;
   }

public:

   inline const uchar* getCharacterSheet(char character) const {
      if (' ' <= character && character <= '~')
         return character_sheet + sheet_length_in_bytes * (character - 0x20);
      return character_sheet + sheet_length_in_bytes * 0xe;
   }

   inline bool isLoaded() const {
      return (bool)character_sheet;
   }

   bool ftmpAssembler(const char* font_file_path) {

      std::fstream file(font_file_path, std::ios::in | std::ios::binary);
      if (!file) {

         file.open("assets/default.ftmp", std::ios::in | std::ios::binary);
         
         if (!file) {
            loadBasic();
            is_basic = true;
            return false;
         }
      }

      file.seekg(-6, file.end);
      ulong sizeof_file = (ulong)file.tellg();

      {
         file.seekg(0, file.beg);
         uchar fontmap_info[6] = {};

         file.read((char*)fontmap_info, 6);

         const uchar extension[] = "FTMP";
         for (uchar i = 0; i < sizeof(extension) - 1; i++) {
            if (extension[i] != fontmap_info[i]) return false;
         }

         height = fontmap_info[4];
         width = fontmap_info[5];
      }

      if (character_sheet && !is_basic) delete[] character_sheet;

      uchar* file_data = new uchar[sizeof_file];
      file.read((char*)file_data, sizeof_file);

      sheet_length = (ulong)height * width;
      sheet_length_in_bytes = ((sheet_length - 1) >> 3) + 1;

      ulong sizeof_full_char_sheet = sheet_length_in_bytes * 95;
      character_sheet = new uchar[sizeof_full_char_sheet];

      uchar* sheet_cursor = character_sheet;
      for (ulong i = 0; i < sizeof_full_char_sheet; i++)
         *sheet_cursor++ = 0;

      char byte_cursor = 7;
      uchar* file_cursor = file_data;
      sheet_cursor = character_sheet;

      for (ulong i = 0; i < 95; i++) {

         for (ulong j = 0; j < sheet_length; j++) {
            if (byte_cursor == -1) { file_cursor++; byte_cursor = 7; }

            sheet_cursor[j >> 3] |= (((*file_cursor >> byte_cursor)) & 1) << (~j & 0b111);
            byte_cursor--;
         }

         sheet_cursor += sheet_length_in_bytes;
      }

      is_basic = false;
      delete[] file_data;

      file.close();
      return true;
   }
};